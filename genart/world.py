# AUTOGENERATED! DO NOT EDIT! File to edit: nbs/06-perlin-noise.ipynb (unless otherwise specified).

__all__ = ['generate_world', 'get_dist_to_coords', 'add_color_mask', 'get_coord_dist_weights', 'weight_world',
           'generate_weighted_coloured_world']

# Cell
def generate_world(shape=(1024, 1024), scale=100.0, octaves=6, persistence=0.5, lacunarity=2, base=None):
    world = np.zeros(shape)

    if base is None:
        base = randrange(1000)

    for i in range(shape[0]):
        for j in range(shape[1]):
            world[i, j] = noise.pnoise2(i/scale,
                                        j/scale,
                                        octaves=octaves,
                                        persistence=persistence,
                                        lacunarity=lacunarity,
                                        repeatx=shape[0],
                                        repeaty=shape[1],
                                        base=base) + 0.5 # we want between 0 - 1, not -0.5 - 0.5

    return world

# Cell
def get_dist_to_coords(world, x_coord=None, y_coord=None):
    width, height = world.shape[0], world.shape[1]

    if x_coord is None:
        x_coord = width/2

    if y_coord is None:
        y_coord = height/2

    X_dist, Y_dist = np.meshgrid(
        np.linspace(0, width, width),
        np.linspace(0, height, height)
    )

    X_dist = np.abs(X_dist - x_coord)
    Y_dist = np.abs(Y_dist - y_coord)

    dist = np.sqrt(X_dist**2 + Y_dist**2)

    return dist

# Cell
def add_color_mask(color_world, mask_colour=(0, 0, 0)):
    for i in track(range(color_world.shape[0])):
        for j in range(color_world.shape[1]):
            if mask[i, j] == True:
                color_world[i, j] = mask_colour

    return color_world

# Cell
def get_coord_dist_weights(world, x_coord=None, y_coord=None):
    weight = get_dist_to_coords(world, x_coord=x_coord, y_coord=y_coord)
    weight = 1 - weight/weight.max()

    return weight

# Cell
def weight_world(world, coords=[(None, None)], weight_adj_func=lambda weight: weight):
    weight = np.zeros(world.shape)

    for x_coord, y_coord in coords:
        weight += weight_adj_func(get_coord_dist_weights(world, x_coord=x_coord, y_coord=y_coord))

    weighted_world = np.multiply(world, weight)
    weighted_world = weighted_world/weighted_world.max()

    return weighted_world

# Cell
def generate_weighted_coloured_world(elevation_max_to_terrain_colour, coords=[(None, None)], weight_adj_func=lambda weight: weight, **world_gen_kwargs):
    world = generate_world(**world_gen_kwargs)
    weighted_world = weight_world(world, coords=coords, weight_adj_func=weight_adj_func)
    weighted_colour_world = add_color(weighted_world, elevation_max_to_terrain_colour)

    return weighted_colour_world